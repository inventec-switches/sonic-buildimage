From 12b94c14072a31a1bc70084d66a52cfc3cd6cb0b Mon Sep 17 00:00:00 2001
From: James Huang <huang.james@inventec.com>
Date: Thu, 17 Jan 2019 22:31:49 +0800
Subject: [PATCH] Enhance the show eeprom command to decode SFP A2 page and
 QSFP 03 page

---
 sonic_sfp/sff8436.py     | 606 +++++++++++++++++++++++++++++++++++++++++++++--
 sonic_sfp/sfputilbase.py |  30 ++-
 2 files changed, 609 insertions(+), 27 deletions(-)

diff --git a/sonic_sfp/sff8436.py b/sonic_sfp/sff8436.py
index f2db5fb..5fb6eff 100644
--- a/sonic_sfp/sff8436.py
+++ b/sonic_sfp/sff8436.py
@@ -345,7 +345,7 @@ class sff8436InterfaceId(sffbase):
                 {'offset': 56,
                  'size'  : 2,
                  'type'  : 'str'},
-	    'Wavelength':
+            'Wavelength':
                 {'offset': 58,
                  'size'  : 2,
                  'type'  : 'qsfp_word'},
@@ -933,6 +933,171 @@ class sff8436Dom(sffbase):
                  'bit': 0,
                  'type': 'bitvalue'}}
 
+    dom_warning_monitor = {
+                   'TempHighWarning':
+                {'offset': 6,
+                 'bit': 5,
+                 'type': 'bitvalue'},
+                   'TempLowWarning':
+                {'offset': 6,
+                 'bit': 4,
+                 'type': 'bitvalue'},
+                   'VccHighWarning':
+                {'offset': 7,
+                 'bit': 5,
+                 'type': 'bitvalue'},
+                   'VccLowWarning':
+                {'offset': 7,
+                 'bit': 4,
+                 'type': 'bitvalue'},
+                   'Rx1PowerHighWarning':
+                {'offset': 9,
+                 'bit': 5,
+                 'type': 'bitvalue'},
+                   'Rx1PowerLowWarning':
+                {'offset': 9,
+                 'bit': 4,
+                 'type': 'bitvalue'},
+                   'Rx2PowerHighWarning':
+                {'offset': 9,
+                 'bit': 1,
+                 'type': 'bitvalue'},
+                   'Rx2PowerLowWarning':
+                {'offset': 9,
+                 'bit': 0,
+                 'type': 'bitvalue'},
+                   'Rx3PowerHighWarning':
+                {'offset': 10,
+                 'bit': 5,
+                 'type': 'bitvalue'},
+                   'Rx3PowerLowWarning':
+                {'offset': 10,
+                 'bit': 4,
+                 'type': 'bitvalue'},
+                   'Rx4PowerHighWarning':
+                {'offset': 10,
+                 'bit': 1,
+                 'type': 'bitvalue'},
+                   'Rx4PowerLowWarning':
+                {'offset': 10,
+                 'bit': 0,
+                 'type': 'bitvalue'},
+                   'Tx1BiasHighWarning':
+                {'offset': 11,
+                 'bit': 5,
+                 'type': 'bitvalue'},
+                   'Tx1BiasLowWarning':
+                {'offset': 11,
+                 'bit': 4,
+                 'type': 'bitvalue'},
+                   'Tx2BiasHighWarning':
+                {'offset': 11,
+                 'bit': 1,
+                 'type': 'bitvalue'},
+                   'Tx2BiasLowWarning':
+                {'offset': 11,
+                 'bit': 0,
+                 'type': 'bitvalue'},
+                   'Tx3BiasHighWarning':
+                {'offset': 12,
+                 'bit': 5,
+                 'type': 'bitvalue'},
+                   'Tx3BiasLowWarning':
+                {'offset': 12,
+                 'bit': 4,
+                 'type': 'bitvalue'},
+                   'Tx4BiasHighWarning':
+                {'offset': 12,
+                 'bit': 1,
+                 'type': 'bitvalue'},
+                   'Tx4BiasLowWarning':
+                {'offset': 12,
+                 'bit': 0,
+                 'type': 'bitvalue'}
+        }
+
+    dom_alarm_monitor = {'TempHighAlarm':
+                {'offset': 6,
+                 'bit': 7,
+                 'type': 'bitvalue'},
+                   'TempLowAlarm':
+                {'offset': 6,
+                 'bit': 6,
+                 'type': 'bitvalue'},
+                   'VccHighAlarm':
+                {'offset': 7,
+                 'bit': 7,
+                 'type': 'bitvalue'},
+                   'VccLowAlarm':
+                {'offset': 7,
+                 'bit': 6,
+                 'type': 'bitvalue'},
+                'Rx1PowerHighAlarm':
+                {'offset': 9,
+                 'bit': 7,
+                 'type': 'bitvalue'},
+                   'Rx1PowerLowAlarm':
+                {'offset': 9,
+                 'bit': 6,
+                 'type': 'bitvalue'},
+                   'Rx2PowerHighAlarm':
+                {'offset': 9,
+                 'bit': 3,
+                 'type': 'bitvalue'},
+                   'Rx2PowerLowAlarm':
+                {'offset': 9,
+                 'bit': 2,
+                 'type': 'bitvalue'},
+                   'Rx3PowerHighAlarm':
+                {'offset': 10,
+                 'bit': 7,
+                 'type': 'bitvalue'},
+                   'Rx3PowerLowAlarm':
+                {'offset': 10,
+                 'bit': 6,
+                 'type': 'bitvalue'},
+                   'Rx4PowerHighAlarm':
+                {'offset': 10,
+                 'bit': 3,
+                 'type': 'bitvalue'},
+                   'Rx4PowerLowAlarm':
+                {'offset': 10,
+                 'bit': 2,
+                 'type': 'bitvalue'},
+                   'Tx1BiasHighAlarm':
+                {'offset': 11,
+                 'bit': 7,
+                 'type': 'bitvalue'},
+                   'Tx1BiasLowAlarm':
+                {'offset': 11,
+                 'bit': 6,
+                 'type': 'bitvalue'},
+                   'Tx2BiasHighAlarm':
+                {'offset': 11,
+                 'bit': 3,
+                 'type': 'bitvalue'},
+                   'Tx2BiasLowAlarm':
+                {'offset': 11,
+                 'bit': 2,
+                 'type': 'bitvalue'},
+                   'Tx3BiasHighAlarm':
+                {'offset': 12,
+                 'bit': 7,
+                 'type': 'bitvalue'},
+                   'Tx3BiasLowAlarm':
+                {'offset': 12,
+                 'bit': 6,
+                 'type': 'bitvalue'},
+                   'Tx4BiasHighAlarm':
+                {'offset': 12,
+                 'bit': 3,
+                 'type': 'bitvalue'},
+                   'Tx4BiasLowAlarm':
+                {'offset': 12,
+                 'bit': 2,
+                 'type': 'bitvalue'}
+        }
+
     dom_module_monitor_values = {'Temperature':
                 {'offset':22,
                  'size':2,
@@ -1016,8 +1181,18 @@ class sff8436Dom(sffbase):
             {'offset': 10,
              'size': 2,
              'type': 'nested',
-             'decode': dom_channel_monitor_values}}
-
+             'decode': dom_channel_monitor_values},
+           'AlarmFlagStatus':
+            {'offset': 6,
+             'size': 8,
+             'type': 'nested',
+             'decode': dom_alarm_monitor},
+           'WarningFlagStatus':
+            {'offset': 6,
+             'size': 8,
+             'type': 'nested',
+             'decode': dom_warning_monitor}
+           }
 # new added parser for some specific values interested by SNMP
 # TO DO: find a way to reuse the definitions in above code, need refactor
     revision_compliance = {
@@ -1095,27 +1270,7 @@ class sff8436Dom(sffbase):
             {'offset': 14,
              'size': 2,
              'type': 'func',
-             'decode': {'func': calc_bias}},
-	'TX1Power':
-            {'offset': 0,
-             'size': 2,
-             'type': 'func',
-             'decode': {'func': calc_tx_power}},
-        'TX2Power':
-            {'offset': 2,
-             'size': 2,
-             'type': 'func',
-             'decode': {'func': calc_tx_power}},
-        'TX3Power':
-            {'offset': 4,
-             'size': 2,
-             'type': 'func',
-             'decode': {'func': calc_tx_power}},
-        'TX4Power':
-            {'offset': 6,
-             'size': 2,
-             'type': 'func',
-             'decode': {'func': calc_tx_power}}
+             'decode': {'func': calc_bias}}
         }
 
     dom_channel_monitor_params_with_tx_power = {
@@ -1224,3 +1379,406 @@ class sff8436Dom(sffbase):
 
     def get_data_pretty(self):
         return sffbase.get_data_pretty(self, self.dom_data)
+
+class sff8436DomThreshold(sffbase):
+
+    version = '1.0'
+
+    def get_calibration_type(self):
+        return self._calibration_type
+
+    def calc_temperature(self, eeprom_data, offset, size):
+        try:
+            cal_type = self.get_calibration_type()
+
+            msb = int(eeprom_data[offset], 16)
+            lsb = int(eeprom_data[offset + 1], 16)
+
+            result = (msb << 8) | (lsb & 0xff)
+            result = self.twos_comp(result, 16)
+
+            if cal_type == 1:
+
+                # Internal calibration
+
+                result = float(result / 256.0)
+                retval = '%.4f' %result + 'C'
+            elif cal_type == 2:
+
+                # External calibration
+
+                # T(C) = T_Slope * T_AD + T_Offset
+                off = self.dom_ext_calibration_constants['T_Slope']['offset']
+                msb_t = int(eeprom_data[off], 16)
+                lsb_t = int(eeprom_data[off + 1], 16)
+                t_slope = (msb_t << 8) | (lsb_t & 0xff)
+
+                off = self.dom_ext_calibration_constants['T_Offset']['offset']
+                msb_t = int(eeprom_data[off], 16)
+                lsb_t = int(eeprom_data[off + 1], 16)
+                t_offset = (msb_t << 8) | (lsb_t & 0xff)
+                t_offset = self.twos_comp(t_offset, 16)
+
+                result = t_slope * result + t_offset
+                result = float(result / 256.0)
+                retval = '%.4f' %result + 'C'
+            else:
+                retval = 'Unknown'
+        except Exception as err:
+            retval = str(err)
+
+        return retval
+
+
+    def calc_voltage(self, eeprom_data, offset, size):
+        try:
+            cal_type = self.get_calibration_type()
+
+            msb = int(eeprom_data[offset], 16)
+            lsb = int(eeprom_data[offset + 1], 16)
+            result = (msb << 8) | (lsb & 0xff)
+
+            if cal_type == 1:
+
+                # Internal Calibration
+
+                result = float(result * 0.0001)
+                #print(indent, name, ' : %.4f' %result, 'Volts')
+                retval = '%.4f' %result + 'Volts'
+            elif cal_type == 2:
+
+                # External Calibration
+
+                # V(uV) = V_Slope * VAD + V_Offset
+                off = self.dom_ext_calibration_constants['V_Slope']['offset']
+                msb_v = int(eeprom_data[off], 16)
+                lsb_v = int(eeprom_data[off + 1], 16)
+                v_slope = (msb_v << 8) | (lsb_v & 0xff)
+
+                off = self.dom_ext_calibration_constants['V_Offset']['offset']
+                msb_v = int(eeprom_data[off], 16)
+                lsb_v = int(eeprom_data[off + 1], 16)
+                v_offset = (msb_v << 8) | (lsb_v & 0xff)
+                v_offset = self.twos_comp(v_offset, 16)
+
+                result = v_slope * result + v_offset
+                result = float(result * 0.0001)
+                #print(indent, name, ' : %.4f' %result, 'Volts')
+                retval = '%.4f' %result + 'Volts'
+            else:
+                #print(indent, name, ' : Unknown')
+                retval = 'Unknown'
+        except Exception as err:
+            retval = str(err)
+
+        return retval
+
+
+    def calc_bias(self, eeprom_data, offset, size):
+        try:
+            cal_type = self.get_calibration_type()
+
+            msb = int(eeprom_data[offset], 16)
+            lsb = int(eeprom_data[offset + 1], 16)
+            result = (msb << 8) | (lsb & 0xff)
+
+            if cal_type == 1:
+                # Internal Calibration
+
+                result = float(result * 0.002)
+                #print(indent, name, ' : %.4f' %result, 'mA')
+                retval = '%.4f' %result + 'mA'
+
+            elif cal_type == 2:
+                # External Calibration
+
+                # I(uA) = I_Slope * I_AD + I_Offset
+                off = self.dom_ext_calibration_constants['I_Slope']['offset']
+                msb_i = int(eeprom_data[off], 16)
+                lsb_i = int(eeprom_data[off + 1], 16)
+                i_slope = (msb_i << 8) | (lsb_i & 0xff)
+
+                off = self.dom_ext_calibration_constants['I_Offset']['offset']
+                msb_i = int(eeprom_data[off], 16)
+                lsb_i = int(eeprom_data[off + 1], 16)
+                i_offset = (msb_i << 8) | (lsb_i & 0xff)
+                i_offset = self.twos_comp(i_offset, 16)
+
+                result = i_slope * result + i_offset
+                result = float(result * 0.002)
+                #print(indent, name, ' : %.4f' %result, 'mA')
+                retval = '%.4f' %result + 'mA'
+            else:
+                retval = 'Unknown'
+        except Exception as err:
+            retval = str(err)
+
+        return retval
+
+
+    def calc_tx_power(self, eeprom_data, offset, size):
+        try:
+            cal_type = self.get_calibration_type()
+
+            msb = int(eeprom_data[offset], 16)
+            lsb = int(eeprom_data[offset + 1], 16)
+            result = (msb << 8) | (lsb & 0xff)
+
+            if cal_type == 1:
+
+                result = float(result * 0.0001)
+                #print(indent, name, ' : ', power_in_dbm_str(result))
+                retval = self.power_in_dbm_str(result)
+
+            elif cal_type == 2:
+
+                # TX_PWR(uW) = TX_PWR_Slope * TX_PWR_AD + TX_PWR_Offset
+                off = self.dom_ext_calibration_constants['TX_PWR_Slope']['offset']
+                msb_tx_pwr = int(eeprom_data[off], 16)
+                lsb_tx_pwr = int(eeprom_data[off + 1], 16)
+                tx_pwr_slope = (msb_tx_pwr << 8) | (lsb_tx_pwr & 0xff)
+
+                off = self.dom_ext_calibration_constants['TX_PWR_Offset']['offset']
+                msb_tx_pwr = int(eeprom_data[off], 16)
+                lsb_tx_pwr = int(eeprom_data[off + 1], 16)
+                tx_pwr_offset = (msb_tx_pwr << 8) | (lsb_tx_pwr & 0xff)
+                tx_pwr_offset = self.twos_comp(tx_pwr_offset, 16)
+
+                result = tx_pwr_slope * result + tx_pwr_offset
+                result = float(result * 0.0001)
+                retval = self.power_in_dbm_str(result)
+            else:
+                retval = 'Unknown'
+        except Exception as err:
+                retval = str(err)
+
+        return retval
+
+
+    def calc_rx_power(self, eeprom_data, offset, size):
+        try:
+            cal_type = self.get_calibration_type()
+
+            msb = int(eeprom_data[offset], 16)
+            lsb = int(eeprom_data[offset + 1], 16)
+            result = (msb << 8) | (lsb & 0xff)
+
+            if cal_type == 1:
+
+                # Internal Calibration
+                result = float(result * 0.0001)
+                #print(indent, name, " : ", power_in_dbm_str(result))
+                retval = self.power_in_dbm_str(result)
+
+            elif cal_type == 2:
+
+                # External Calibration
+
+                # RX_PWR(uW) = RX_PWR_4 * RX_PWR_AD +
+                #          RX_PWR_3 * RX_PWR_AD +
+                #          RX_PWR_2 * RX_PWR_AD +
+                #          RX_PWR_1 * RX_PWR_AD +
+                #          RX_PWR(0)
+                off = self.dom_ext_calibration_constants['RX_PWR_4']['offset']
+                rx_pwr_byte3 = int(eeprom_data[off], 16)
+                rx_pwr_byte2 = int(eeprom_data[off + 1], 16)
+                rx_pwr_byte1 = int(eeprom_data[off + 2], 16)
+                rx_pwr_byte0 = int(eeprom_data[off + 3], 16)
+                rx_pwr_4 = (rx_pwr_byte3 << 24) | (rx_pwr_byte2 << 16) | (rx_pwr_byte1 << 8) | (rx_pwr_byte0 & 0xff)
+
+                off = self.dom_ext_calibration_constants['RX_PWR_3']['offset']
+                rx_pwr_byte3 = int(eeprom_data[off], 16)
+                rx_pwr_byte2 = int(eeprom_data[off + 1], 16)
+                rx_pwr_byte1 = int(eeprom_data[off + 2], 16)
+                rx_pwr_byte0 = int(eeprom_data[off + 3], 16)
+                rx_pwr_3 = (rx_pwr_byte3 << 24) | (rx_pwr_byte2 << 16) | (rx_pwr_byte1 << 8) | (rx_pwr_byte0 & 0xff)
+
+                off = self.dom_ext_calibration_constants['RX_PWR_2']['offset']
+                rx_pwr_byte3 = int(eeprom_data[off], 16)
+                rx_pwr_byte2 = int(eeprom_data[off + 1], 16)
+                rx_pwr_byte1 = int(eeprom_data[off + 2], 16)
+                rx_pwr_byte0 = int(eeprom_data[off + 3], 16)
+                rx_pwr_2 = (rx_pwr_byte3 << 24) | (rx_pwr_byte2 << 16) | (rx_pwr_byte1 << 8) | (rx_pwr_byte0 & 0xff)
+
+                off = self.dom_ext_calibration_constants['RX_PWR_1']['offset']
+                rx_pwr_byte3 = int(eeprom_data[off], 16)
+                rx_pwr_byte2 = int(eeprom_data[off + 1], 16)
+                rx_pwr_byte1 = int(eeprom_data[off + 2], 16)
+                rx_pwr_byte0 = int(eeprom_data[off + 3], 16)
+                rx_pwr_1 = (rx_pwr_byte3 << 24) | (rx_pwr_byte2 << 16) | (rx_pwr_byte1 << 8) | (rx_pwr_byte0 & 0xff)
+
+                off = self.dom_ext_calibration_constants['RX_PWR_0']['offset']
+                rx_pwr_byte3 = int(eeprom_data[off], 16)
+                rx_pwr_byte2 = int(eeprom_data[off + 1], 16)
+                rx_pwr_byte1 = int(eeprom_data[off + 2], 16)
+                rx_pwr_byte0 = int(eeprom_data[off + 3], 16)
+                rx_pwr_0 = (rx_pwr_byte3 << 24) | (rx_pwr_byte2 << 16) | (rx_pwr_byte1 << 8) | (rx_pwr_byte0 & 0xff)
+
+                rx_pwr = (rx_pwr_4 * result) + (rx_pwr_3 * result) + (rx_pwr_2 * result) + (rx_pwr_1 * result) + rx_pwr_0
+
+                result = float(result * 0.0001)
+                #print(indent, name, " : ", power_in_dbm_str(result))
+                retval = self.power_in_dbm_str(result)
+            else:
+                retval = 'Unknown'
+        except Exception as err:
+            retval = str(err)
+
+        return retval
+
+
+    dom_module_threshold_values = {
+                'TempHighAlarm':
+                {'offset':0,
+                 'size':2,
+                 'type': 'func',
+                 'decode': { 'func':calc_temperature}},
+                'TempLowAlarm':
+                {'offset':2,
+                 'size':2,
+                 'type': 'func',
+                 'decode': { 'func':calc_temperature}},
+                'TempHighWarning':
+                {'offset':4,
+                 'size':2,
+                 'type': 'func',
+                 'decode': { 'func':calc_temperature}},
+                'TempLowWarning':
+                {'offset':6,
+                 'size':2,
+                 'type': 'func',
+                 'decode': { 'func':calc_temperature}},
+                'VoltageHighAlarm':
+                {'offset':16,
+                 'size':2,
+                 'type': 'func',
+                 'decode': { 'func':calc_voltage}},
+                'VoltageLowAlarm':
+                {'offset':18,
+                 'size':2,
+                 'type': 'func',
+                 'decode': { 'func':calc_voltage}},
+                'VoltageHighWarning':
+                {'offset':20,
+                 'size':2,
+                 'type': 'func',
+                 'decode': { 'func':calc_voltage}},
+                'VoltageLowWarning':
+                {'offset':22,
+                 'size':2,
+                 'type': 'func',
+                 'decode': { 'func':calc_voltage}},
+                'RXPowerHighAlarm':
+                {'offset':48,
+                 'size':2,
+                 'type': 'func',
+                 'decode': { 'func':calc_rx_power}},
+                'RXPowerLowAlarm':
+                {'offset':50,
+                 'size':2,
+                 'type': 'func',
+                 'decode': { 'func':calc_rx_power}},
+                'RXPowerHighWarning':
+                {'offset':52,
+                 'size':2,
+                 'type': 'func',
+                 'decode': { 'func':calc_rx_power}},
+                'RXPowerLowWarning':
+                {'offset':54,
+                 'size':2,
+                 'type': 'func',
+                 'decode': { 'func':calc_rx_power}},
+                'BiasHighAlarm':
+                {'offset':56,
+                 'size':2,
+                 'type': 'func',
+                 'decode': { 'func':calc_bias}},
+                'BiasLowAlarm':
+                {'offset':58,
+                 'size':2,
+                 'type': 'func',
+                 'decode': { 'func':calc_bias}},
+                'BiasHighWarning':
+                {'offset':60,
+                 'size':2,
+                 'type': 'func',
+                 'decode': { 'func':calc_bias}},
+                'BiasLowWarning':
+                {'offset':62,
+                 'size':2,
+                 'type': 'func',
+                 'decode': { 'func':calc_bias}},
+                'TXPowerHighAlarm':
+                {'offset': 64,
+                 'size': 2,
+                 'type': 'func',
+                 'decode': {'func': calc_tx_power}},
+                'TXPowerLowAlarm':
+                {'offset': 66,
+                 'size': 2,
+                 'type': 'func',
+                 'decode': {'func': calc_tx_power}},
+                'TXPowerHighWarning':
+                {'offset': 68,
+                 'size': 2,
+                 'type': 'func',
+                 'decode': {'func': calc_tx_power}},
+                'TXPowerLowWarning':
+                {'offset': 70,
+                 'size': 2,
+                 'type': 'func',
+                 'decode': {'func': calc_tx_power}}
+        }
+
+    dom_map = {
+           'AwThresholds':
+            {'offset': 0,
+             'size': 72,
+             'type': 'nested',
+             'decode': dom_module_threshold_values}
+           }
+
+
+    def __init__(self, eeprom_raw_data=None, calibration_type=1):
+        self._calibration_type = calibration_type
+        start_pos = 0
+
+        if eeprom_raw_data != None:
+            self.dom_data = sffbase.parse(self, self.dom_map,
+                          eeprom_raw_data, start_pos)
+
+    def parse(self, eeprom_raw_data, start_pos):
+        return sffbase.parse(self, self.dom_map, eeprom_raw_data,
+                    start_pos)
+
+# Parser functions for specific values interested by SNMP
+    def parse_sfp_dom_rev(self, type_raw_data, start_pos):
+        return sffbase.parse(self, self.sfp_dom_rev, type_raw_data, start_pos)
+
+    def parse_temperature(self, eeprom_raw_data, start_pos):
+        return sffbase.parse(self, self.dom_module_temperature, eeprom_raw_data,
+                    start_pos)
+
+    def parse_voltage(self, eeprom_raw_data, start_pos):
+        return sffbase.parse(self, self.dom_module_voltage, eeprom_raw_data,
+                    start_pos)
+
+    def parse_channel_monitor_params(self, eeprom_raw_data, start_pos):
+        return sffbase.parse(self, self.dom_channel_monitor_params, eeprom_raw_data,
+                    start_pos)
+
+    def parse_channel_monitor_params_with_tx_power(self, eeprom_raw_data, start_pos):
+        return sffbase.parse(self, self.dom_channel_monitor_params_with_tx_power, eeprom_raw_data,
+                    start_pos)
+
+    def dump_pretty(self):
+        if self.dom_data == None:
+            print('Object not initialized, nothing to print')
+            return
+        sffbase.dump_pretty(self, self.dom_data)
+
+    def get_data(self):
+        return self.dom_data
+
+    def get_data_pretty(self):
+        return sffbase.get_data_pretty(self, self.dom_data)
diff --git a/sonic_sfp/sfputilbase.py b/sonic_sfp/sfputilbase.py
index 701b345..d6adc20 100644
--- a/sonic_sfp/sfputilbase.py
+++ b/sonic_sfp/sfputilbase.py
@@ -16,6 +16,7 @@ try:
     from sff8472 import sff8472Dom
     from sff8436 import sff8436InterfaceId
     from sff8436 import sff8436Dom
+    from sff8436 import sff8436DomThreshold
 except ImportError as e:
     raise ImportError("%s - required module not found" % str(e))
 
@@ -212,7 +213,19 @@ class SfpUtilBase(object):
         sysfs_i2c_adapter_base_path = "/sys/class/i2c-adapter"
 
         if port_num in self.port_to_eeprom_mapping.keys():
-            sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[port_num]
+            if type(self.port_to_eeprom_mapping[port_num]) is list:
+                for eeprom_path in self.port_to_eeprom_mapping[port_num] :
+                    # According to the "devid" requirements, return different EEPROM paths.
+                    if eeprom_path.find("eeprom") > -1 :
+                        sfp_port_a0_path = eeprom_path
+                    else:
+                        sfp_port_a2_path = eeprom_path
+                if devid == self.DOM_EEPROM_ADDR :
+                    sysfs_sfp_i2c_client_eeprom_path = sfp_port_a2_path
+                else:
+                    sysfs_sfp_i2c_client_eeprom_path = sfp_port_a0_path
+            else:
+                sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[port_num]
         else:
             sysfs_i2c_adapter_base_path = "/sys/class/i2c-adapter"
 
@@ -280,7 +293,11 @@ class SfpUtilBase(object):
             print("Error: reading sysfs file %s" % sysfs_sfp_i2c_client_eeprom_path)
             return None
 
-        eeprom_raw = self._read_eeprom_specific_bytes(sysfsfile_eeprom, offset, num_bytes)
+        # According to the "devid" requirements, return different EEPROM paths.
+        if devid == self.DOM_EEPROM_ADDR  :
+            eeprom_raw = self._read_eeprom_specific_bytes(sysfsfile_eeprom, offset, 128)
+        else:
+            eeprom_raw = self._read_eeprom_specific_bytes(sysfsfile_eeprom, offset, num_bytes)
 
         try:
             sysfsfile_eeprom.close()
@@ -586,7 +603,8 @@ class SfpUtilBase(object):
     def get_eeprom_dom_raw(self, port_num):
         if port_num in self.qsfp_ports:
             # QSFP DOM EEPROM is also at addr 0x50 and thus also stored in eeprom_ifraw
-            return None
+            return self._read_eeprom_devid(port_num, self.DOM_EEPROM_ADDR, 0)
+            #return None
         else:
             # Read dom eeprom at addr 0x51
             return self._read_eeprom_devid(port_num, self.DOM_EEPROM_ADDR, 0)
@@ -615,6 +633,12 @@ class SfpUtilBase(object):
             sfpd_obj = sff8436Dom(eeprom_ifraw)
             if sfpd_obj is not None:
                 sfp_data['dom'] = sfpd_obj.get_data_pretty()
+
+            if eeprom_domraw is not None:
+                sfpt_obj = sff8436DomThreshold(eeprom_domraw)
+                if sfpt_obj is not None:
+                    sfp_data['dom']["data"].update(sfpt_obj.get_data_pretty()["data"])
+
             return sfp_data
 
         sfpi_obj = sff8472InterfaceId(eeprom_ifraw)
-- 
2.1.4

